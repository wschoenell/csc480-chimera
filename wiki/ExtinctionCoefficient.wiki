#summary How Chimera will compute the Extinction Coefficient

= Introduction =

Our requirements document is found here: http://csc480-chimera.googlecode.com/files/ExtinctionCoefficient_Requirements_Doc.pdf

Steps to compute extinction coefficient:

 * `public computeExtinctionCoefficient(raDec[], latitude[], flux[])` called by EXTERNAL code.
   # For each element in raDec, latitude, flux call computeEC. This returns magnititude, airmass. Store in `magnitude[], airmass[]`.
   # Run a least squares fit on magnitude, airmass.
   # Return the numeric value here (the extinction coefficient).

 * `private computeEC(raDec, latitude, flux)` called by computeExtinctionCoefficient. Returns Airmass and Magnitude.
   # Compute Local Sidereal Time (lst) (call LST(self) in core/site.py)
   # Call function raDectoAltAz(raDec, latitude, lst) in position.py. This returns altitude and azimuth.
   # Compute airmass = 1/cos(altitude).
   # Compute magnitude = 2.5*log(flux)
   # return airmass and magnitude.

Note there will also be a least squares package we will include with this, but this is the main outline of what we have to do. My thought is that we use this one: http://www.aps.anl.gov/bcda/dataVis/fit.py.html

Also, the data in computeExtinctionCoefficient can be used for a graph.

Note - in case LST doesn't work, Shashi gave me this site: http://www.pietro.org/Astro_Util_StaticDemo/FDetailSiderealConv.htm

Here is some code which needs refinement, but should be almost working:
{{{
from seeing import Seeing 
from chimera.core.site import Site
from chimera.util.position import Position
from chimera.util.coord import Coord
import numpy as np
import math

#This sets latitude, we need to pull this from somewhere eventually
latitude = Coord.fromHMS('-22:32:04.000')

seeing = Seeing()

#TEMP:
site = Site()

# This is the sample RA and DEC from shashi for Landolt star
ra = Coord.fromHMS('20:42:14')
dec = Coord.fromHMS('00:09:01')

# Make a tuple for the RA and DEC to pass to compute methods
aTuple = ra, dec

# Make a position object from that tuple
radec = [Position(aTuple)]

#Computes the coefficient. takes arrays: flux, altitude
def computeExtinctionCoefficient(flux, altitudeArr):
	#These will be needed for our output.
	magnitude = []
	airmass = []

	#Make radec a global var
	global radec

	#Iterate over each of the arrays to call computeEC
	for i in range(len(flux)):
		temparr = computeEC(flux[i], altitudeArr[i])
		magnitude.append(temparr[0])
		airmass.append(temparr[1])

	#Print out magnitudes
	print "Magnitudes:"
	print magnitude

	#Print out airmasses
	print "Airmasses:"
	print airmass

	#Now run a least squares fit and return the slope of the line.
	#We arent sure which order these come back in!
	m,b = np.polyfit(airmass,magnitude,1)

	#Print out m,b
	print "M value:", m
	print "B value:", b

	return m

#Compute the magnitude and airmass from specific raDec (of type Position), latitude, flux values.
def computeEC(flux, altitude):
	#airmass calculation
	airmass = 1/math.cos(altitude)
	#magnitude calculation
	magnitude = 2.5*math.log(flux)
	return [magnitude,airmass]

# Array of the 5 images being used to test our module
images = ["images/landolt-SA112223-0001.fits", "images/landolt-SA112223-0002.fits", "images/landolt-SA112223-0003.fits", "images/landolt-SA112223-0004.fits", "images/landolt-SA112223-0005.fits"]

# Array of all the altitudes for our 5 images being tested
altitudeArr = ['67:18:43.000', '67:18:09.000', '67:08:16.000', '66:46:22.000', '66:28:48.000']

# Create an empty array for the altitudes which will be stored in Radians instead of Degrees
altRadiansArr = []

# Create array of fluxes that will be populated each time seeing is run on an image
fluxArr = []

for i in range(len(images)):
	#Runs seeing on each image
	seeing.run(images[i])

	#Gets whichever star is closest to known RA and DEC
	star = seeing.getStarClosestTo(ra, dec)

	#Get the flux of the star for each image given to seeing
	flux = seeing.getFlux(star)

	#Add flux values to the array
	fluxArr.append(flux)

	#Turns altitude into a degree before turning them into radians (Note: This was done because we could only convert to degree from HMS)
	tmpAltitude = Coord.fromHMS(altitudeArr[i])
	
	#Add altitude in radians to array (Note: the long decimal is Pi/180 because we couldn't get the radians conversion to work)
	altRadiansArr.append(tmpAltitude*0.0174532925)

print "Testing computeExtinctionCoefficient"
print  computeExtinctionCoefficient(fluxArr, altRadiansArr)
}}}

Further description of the process is available at: http://star-www.rl.ac.uk/star/dvi/sc6.htx/node15.html

*Plotting the graph*

This code will generate an image plot using gnuplot. It currently takes as parameters a file name, labels for the x and y axes, arrays of x and y coordinates, and m and b for the best-fit line. The graphical output still needs some refinement, but it should work for now.
{{{
import os

# Generates a data file (fileName.dat), a gnuplot batch file (fileName.gnu)
#  and a PNG image of the plot (fileName.png)
def plotViaGnuplot(fileName, x_label, x_list, y_label, y_list, m, b):
    # Set path to the gnuplot binary
    gpPath = "gnuplot"

    # Set output type and file extension
    terminalType = "png"    # Alternatives: jpeg, gif, postscript, pdf, etc.
    extension = ".png"      # Alternatives: jpg, gif, ps, pdf, etc.

    # Create space-delimited data file
    file = open(fileName + ".dat", "w")
    for i in range(len(x_list)):
        print >> file, str(x_list[i]) + ' ' + str(y_list[i])
    file.flush()
    file.close()

    # Create gnuplot batch file
    file = open(fileName + ".gnu", "w")
    print >> file, "set terminal " + terminalType
    print >> file, "set output \"" + fileName + extension + "\""
    print >> file, "set xlabel \"" + x_label + "\""
    print >> file, "set ylabel \"" + y_label + "\""
    print >> file, "set xrange [ " + str(min(x_list) - 1) + " : " + str(max(x_list) + 1) + " ]"
    print >> file, "set yrange [ " + str(min(y_list) - 1) + " : " + str(max(y_list) + 1) + " ]"
    print >> file, "set mxtics 5"
    print >> file, "set mytics 5"
    print >> file, "set xtics " + str((max(x_list) - min(x_list)) / 5)
    print >> file, "set ytics " + str((max(y_list) - min(y_list)) / 5)
    print >> file, "f(x) = " + str(m) + " * x + " + str(b)
    print >> file, "plot f(x) notitle with lines, \"" + fileName + ".dat\" using 1:2 notitle"
    file.flush()
    file.close()

    # Run gnuplot, passing in the batch file
    os.system(gpPath + " " + fileName + ".gnu")
}}}

*Chimera Extinction Coefficient Module Test Plan*

The test plan we have developed for the Extinction Coefficient module of the Chimera robotic telescope application is rooted firmly in the use of PyUnit tests. We will test the known bounds of the inputs to ensure they are within the acceptable ranges, and we will test on specific data to ensure that we are presented with a value equal to what is expected.

Known Input Bounds:

 * Ra: Ranges from 0-180 degrees
 * Dec: Ranges from 0-360 degrees
 * Latitude: Ranges from 0-180 degrees
 * Flux: Greater than 0

*Database Stub Class*
{{{
class DatabaseStub:
    """
    Preliminary interface to database that simply returns hard-coded data
    """
    def queryStar(self, RA, dec):
        """
        TODO - code to communicate with databse interface
        Will search database to return all stars at a certain RA/Dec
        """
        return 0

    def queryMagnitude(self, starID)
        """
        TODO - code to communicate with databse interface
        Retrieves the magnitude of the designated star (starID)
        """
        return 2

    def queryAirMass(self, starID):
        """
        TODO - code to communicate with databse interface
        Retrieves the air mass of the designated star (starID)
        """
        return 1

    def queryFlux(self, starID):
        """
        TODO - code to communicate with databse interface
        Retrieves the flux of the designated star (starID)
        """
        return 3

    def writeEC(self, extID, EC):
        """        
        TODO - code to communicate with databse interface
        Writes extinction coefficient (EC) to the designated EC. table (extID)
        """
        return EC

    def writeTimeStart(self, extID, time):
        """        
        TODO - code to communicate with databse interface
        Writes LST start time (time) to the designated EC. table (extID)
        """
        return time

    def writeTimeEnd(self, extID, time):
        """
        TODO - code to communicate with databse interface
        Writes LST end time (time) to the designated EC. table (extID)
        """
        return time

    def createTable(self, extID):
        """
        TODO - code to communicate with databse interface
        Writes LST start (time) to the designated EC. table (extID)
        """    
        return extID
}}}