#summary How Chimera will compute the Extinction Coefficient

= Introduction =

Our requirements document is found here: http://csc480-chimera.googlecode.com/files/ExtinctionCoefficient_Requirements_Doc.pdf

Steps to compute extinction coefficient:

 * `public computeExtinctionCoefficient(raDec[], latitude[], flux[])` called by EXTERNAL code.
   # For each element in raDec, latitude, flux call computeEC. This returns magnititude, airmass. Store in `magnitude[], airmass[]`.
   # Run a least squares fit on magnitude, airmass.
   # Return the numeric value here (the extinction coefficient).

 * `private computeEC(raDec, latitude, flux)` called by computeExtinctionCoefficient. Returns Airmass and Magnitude.
   # Compute Local Sidereal Time (lst) (call LST(self) in core/site.py)
   # Call function raDectoAltAz(raDec, latitude, lst) in position.py. This returns altitude and azimuth.
   # Compute airmass = 1/cos(altitude).
   # Compute magnitude = 2.5*log(flux)
   # return airmass and magnitude.

Note there will also be a least squares package we will include with this, but this is the main outline of what we have to do. My thought is that we use this one: http://www.aps.anl.gov/bcda/dataVis/fit.py.html

Also, the data in computeExtinctionCoefficient can be used for a graph.

Note - in case LST doesn't work, Shashi gave me this site: http://www.pietro.org/Astro_Util_StaticDemo/FDetailSiderealConv.htm

Here is some code which needs refinement, but should be almost working:
{{{
from chimera.core.site import Site
from chimera.util.position import Position
from chimera.util.coord import Coord
import numpy as np
#import numpy.lib.polynomial
import math

#This sets latitude, we need to pull this from somewhere eventually
latitude = 40
site = Site()

#Heres a sample test
aTuple = Coord.fromD(10),Coord.fromD(20)
radec = Position(aTuple)
aTuple2 = Coord.fromD(10),Coord.fromD(22)
radec2 = Position(aTuple2)

#Computes the coefficient. takes arrays: raDec, latitude, flux.
def computeExtinctionCoefficient(raDec, flux, lst):
        #These will be needed for our output.
        magnitude = []
        airmass = []

        #Iterate over each of the arrays to call computeEC
        for i in range(len(raDec)):
                temparr = computeEC(raDec[i], flux[i], lst[i])
                magnitude.append(temparr[0])
                airmass.append(temparr[1])

        #Now run a least squares fit and return the slope of the line.
        #We arent sure which order these come back in!
        m,b = np.polyfit(magnitude,airmass,1)
        return m

#Compute the magnitude and airmass from specific raDec (of type Position), latitude, flux values.
def computeEC(raDec, flux, lst):
        #this returns the altitude and azimuth
        altAz = radec.raDecToAltAz(raDec, latitude, lst)
        #Get the altitude
        altitude = altAz.alt
        #airmass calculation
        airmass = 1/math.cos(altitude)
        #magnitude calculation
        magnitude = 2.5*math.log(flux)
        return [magnitude,airmass]

print "Testing computeEC"
print computeEC(radec, 10, site.LST())

print "Testing computeExtinctionCoefficient"
print computeExtinctionCoefficient([radec,radec2], [10,15], [site.LST(),site.LST()])

}}}

Further description of the process is available at: http://star-www.rl.ac.uk/star/dvi/sc6.htx/node15.html

*Plotting the graph*

This code will generate an image plot using gnuplot. It currently takes as parameters a file name, labels for the x and y axes, arrays of x and y coordinates, and m and b for the best-fit line. The graphical output still needs some refinement, but it should work for now.
{{{
import os

# Generates a data file (fileName.dat), a gnuplot batch file (fileName.gnu)
#  and a PNG image of the plot (fileName.png)
def plotViaGnuplot(fileName, x_label, x_list, y_label, y_list, m, b):
    # Set path to the gnuplot binary
    gpPath = "gnuplot"

    # Set output type and file extension
    terminalType = "png"    # Alternatives: jpeg, gif, postscript, pdf, etc.
    extension = ".png"      # Alternatives: jpg, gif, ps, pdf, etc.

    # Create space-delimited data file
    file = open(fileName + ".dat", "w")
    for i in range(len(x_list)):
        print >> file, str(x_list[i]) + ' ' + str(y_list[i])
    file.flush()
    file.close()

    # Create gnuplot batch file
    file = open(fileName + ".gnu", "w")
    print >> file, "set terminal " + terminalType
    print >> file, "set output \"" + fileName + extension + "\""
    print >> file, "set xlabel \"" + x_label + "\""
    print >> file, "set ylabel \"" + y_label + "\""
    print >> file, "set xrange [ " + str(min(x_list) - 1) + " : " + str(max(x_list) + 1) + " ]"
    print >> file, "set yrange [ " + str(min(y_list) - 1) + " : " + str(max(y_list) + 1) + " ]"
    print >> file, "set mxtics 5"
    print >> file, "set mytics 5"
    print >> file, "set xtics " + str((max(x_list) - min(x_list)) / 5)
    print >> file, "set ytics " + str((max(y_list) - min(y_list)) / 5)
    print >> file, "f(x) = " + str(m) + " * x + " + str(b)
    print >> file, "plot f(x) notitle with lines, \"" + fileName + ".dat\" using 1:2 notitle"
    file.flush()
    file.close()

    # Run gnuplot, passing in the batch file
    os.system(gpPath + " " + fileName + ".gnu")
}}}

*Chimera Extinction Coefficient Module Test Plan*

The test plan we have developed for the Extinction Coefficient module of the Chimera robotic telescope application is rooted firmly in the use of PyUnit tests. We will test the known bounds of the inputs to ensure they are within the acceptable ranges, and we will test on specific data to ensure that we are presented with a value equal to what is expected.

Known Input Bounds:

 * Ra: Ranges from 0-180 degrees
 * Dec: Ranges from 0-360 degrees
 * Latitude: Ranges from 0-180 degrees
 * Flux: Greater than 0